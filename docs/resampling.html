<h2>Resampling</h2>
<p><strong>Algorithm</strong> : Upsampling<br />
<strong>Input</strong> :
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">{</mo><mi>v</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mi>y</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mi>t</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mn>0</mn><mo>≤</mo><mi>k</mi><mo>≤</mo><mi>n</mi><mo stretchy="true" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\left\{ v\lbrack k\rbrack = \left( x\lbrack k\rbrack,y\lbrack k\rbrack,t\lbrack k\rbrack \right),0 \leq k \leq n \right\}</annotation></semantics></math>
and a target rate <code>sampling_min_output_rate</code>, Interpolate
time and position between each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
by linearly adding interpolated values<br />
This is done by adding linearly interpolated values so that the output
stream is
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">{</mo><mi>v</mi><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo stretchy="false" form="postfix">]</mo><mo>,</mo><munder><munder><mrow><msub><mi>u</mi><mn>0</mn></msub><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>u</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>n</mi><mn>0</mn></msub><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><mo accent="true">⏟</mo></munder><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> interpolated</mtext></mrow></munder><mo>,</mo><mi>v</mi><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo><mo>,</mo><munder><munder><mrow><msub><mi>u</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>u</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>n</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><mo accent="true">⏟</mo></munder><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> interpolated</mtext></mrow></munder><mo>,</mo><mi>v</mi><mo stretchy="false" form="prefix">[</mo><mn>2</mn><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mi>…</mi><mo stretchy="true" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\left\{ v\lbrack 0\rbrack,\underset{\text{ interpolated}}{\underbrace{u_{0}\lbrack 1\rbrack,\ldots,u_{0}\left\lbrack n_{0} - 1 \right\rbrack}},v\lbrack 1\rbrack,\underset{\text{ interpolated}}{\underbrace{u_{1}\lbrack 1\rbrack,\ldots,u_{1}\left\lbrack n_{1} - 1 \right\rbrack}},v\lbrack 2\rbrack,\ldots \right\}</annotation></semantics></math>
Each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>i</mi></msub><annotation encoding="application/x-tex">n_{i}</annotation></semantics></math>
is the minimum integer such that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mfrac><mrow><mi>t</mi><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo><mo>−</mo><mi>t</mi><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><msub><mi>n</mi><mi>i</mi></msub></mfrac><mo>&lt;</mo><msub><mi>Δ</mi><mtext mathvariant="normal">target</mtext></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>⇔</mo></mtd><mtd columnalign="left" style="text-align: left"><msub><mi>n</mi><mi>i</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">⌈</mo><mfrac><mrow><mi>t</mi><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo><mo>−</mo><mi>t</mi><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><msub><mi>Δ</mi><mtext mathvariant="normal">target</mtext></msub></mfrac><mo stretchy="true" form="postfix">⌉</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
 &amp; \frac{t\lbrack i\rbrack - t\lbrack i - 1\rbrack}{n_{i}} &lt; \Delta_{\text{target}} \\
 \Leftrightarrow &amp; n_{i} = \left\lceil \frac{t\lbrack i + 1\rbrack - t\lbrack i\rbrack}{\Delta_{\text{target}}} \right\rceil
\end{aligned}</annotation></semantics></math> and the linear
interpolation means
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>j</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mfrac><mi>k</mi><msub><mi>n</mi><mi>j</mi></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mi>v</mi><mo stretchy="false" form="prefix">[</mo><mi>j</mi><mo stretchy="false" form="postfix">]</mo><mo>+</mo><mfrac><mi>k</mi><msub><mi>n</mi><mi>i</mi></msub></mfrac><mi>v</mi><mo stretchy="false" form="prefix">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">u_{j}\lbrack k\rbrack = \left( 1 - \frac{k}{n_{j}} \right)v\lbrack j\rbrack + \frac{k}{n_{i}}v\lbrack j + 1\rbrack</annotation></semantics></math><br />
<strong>Output</strong> :
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">{</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mi>′</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mi>′</mi><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mi>y</mi><mi>′</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mi>′</mi><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mi>t</mi><mi>′</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mi>′</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mn>0</mn><mo>≤</mo><mi>k</mi><mo>;</mo><mo>≤</mo><mi>n</mi><mi>′</mi><mo stretchy="true" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\left\{ \left( x\prime\lbrack k\prime\rbrack,y\prime\lbrack k\prime\rbrack,t\prime\lbrack k\prime\rbrack \right),0 \leq k; \leq n\prime \right\}</annotation></semantics></math>
the upsampled position and times. This verifies
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>k</mi><mi>′</mi><mo>,</mo><mi>t</mi><mi>′</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mi>′</mi><mo stretchy="false" form="postfix">]</mo><mo>−</mo><mi>t</mi><mi>′</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mi>′</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo><mo>&lt;</mo><msub><mi>Δ</mi><mrow><mtext mathvariant="normal">target </mtext><mspace width="0.333em"></mspace></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">\forall k\prime,t\prime\lbrack k\prime\rbrack - t\prime\lbrack k\prime - 1\rbrack &lt; \Delta_{\text{target }} = \frac{1}{}</annotation></semantics></math>,
<strong>Remark</strong> : As this is a streaming algorithm, we only
calculate this interpolation with respect to the latest stroke
position.</p>
